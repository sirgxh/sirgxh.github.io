<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux系统python3使用libreoffice将word转换为pdf文件</title>
    <link href="/2022/07/03/66346/"/>
    <url>/2022/07/03/66346/</url>
    
    <content type="html"><![CDATA[<h3 id="1、安装包"><a href="#1、安装包" class="headerlink" title="1、安装包"></a>1、安装包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install libreoffice -y<br></code></pre></td></tr></table></figure><h3 id="2、命令转换word-to-pdf"><a href="#2、命令转换word-to-pdf" class="headerlink" title="2、命令转换word to pdf"></a>2、命令转换word to pdf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@VM-80-27-centos ~]# libreoffice --headless --convert-to pdf /data/demo.docx --outdir /data/a/  <br>convert /data/demo.docx -&gt; /data/a//demo.pdf using filter : writer_pdf_Export<br></code></pre></td></tr></table></figure><ul><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">libreoffice --headless --convert-to pdf docx文件路径  --outdir 输出的文件路径<br></code></pre></td></tr></table></figure><h3 id="3、python脚本讲word转换为pdf（Linux系统）"><a href="#3、python脚本讲word转换为pdf（Linux系统）" class="headerlink" title="3、python脚本讲word转换为pdf（Linux系统）"></a>3、python脚本讲word转换为pdf（Linux系统）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">linux system word to pdf</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">doc2pdf_linux</span>(<span class="hljs-params">docPath, pdfPath</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    convert a doc/docx document to pdf format (linux only, requires libreoffice)</span><br><span class="hljs-string">    :param doc: path to document</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 转换word to pdf主要命令</span><br>    cmd = <span class="hljs-string">&#x27;libreoffice --headless --convert-to pdf&#x27;</span>.split() + [docPath] + [<span class="hljs-string">&#x27;--outdir&#x27;</span>] + [pdfPath]<br>    <span class="hljs-comment"># 开启一个进程执行这个转换命令</span><br>    p = subprocess.Popen(cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE)<br>    <span class="hljs-comment"># 设置30秒超时</span><br>    p.wait(timeout=<span class="hljs-number">30</span>)<br>    <span class="hljs-comment"># 将该命令的标准输出和错误输出赋值给两个变量名称</span><br>    stdout, stderr = p.communicate()<br>    <span class="hljs-comment"># 如果错误输出存在，则抛出异常</span><br>    <span class="hljs-keyword">if</span> stderr:<br>        <span class="hljs-keyword">raise</span> subprocess.SubprocessError(stderr)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    wordpath=<span class="hljs-string">&#x27;/data/demo.docx&#x27;</span><br>    pdfpath=<span class="hljs-string">&#x27;/data/test/&#x27;</span><br>    doc2pdf_linux(wordpath,pdfpath)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统开启启动报错：/dev/vda1 contains a file system with errors, check forced.</title>
    <link href="/2022/06/03/53264/"/>
    <url>/2022/06/03/53264/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用云服务器，远程无法登录，通过控制台vnc登录后看到这样的报错，如下：</p><p>Checking filesystems</p><p>&#x2F;dev&#x2F;vda1 contains a file system with errors, check forced.</p><p>&#x2F;dev&#x2F;vda1: Inodes that were part of a corrupted orphan linked list found.</p><p>&#x2F;dev&#x2F;vda1: UNEXPECTED INCONSISTENCY: RUN fsck MANUALLY. </p><p>(i.e., without -a or -p options)  FAILED</p><p><img src="/img/byriareeso.png" alt="报错截图"></p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>一般是强制关机或服务器突然断电所致。</p><h2 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h2><h4 id="1、做备份"><a href="#1、做备份" class="headerlink" title="1、做备份"></a>1、做备份</h4><p>首先要<a href="https://cloud.tencent.com/document/product/362/5755?from=10680">创建快照</a>备份当前服务器状态，这样若修复过程中遇到问题或修复未果，我们则可以通过回滚快照恢复服务器到当前的状态。</p><h4 id="2、登录服务器"><a href="#2、登录服务器" class="headerlink" title="2、登录服务器"></a>2、登录服务器</h4><p>当前服务器为故障状态，无法远程登录， 需要登录<a href="https://console.cloud.tencent.com/cvm/instance/index?rid=1">腾讯云控制台</a>，然后使用<a href="https://cloud.tencent.com/document/product/213/35701?from=10680">VNC登录</a>服务器。</p><h4 id="3、根据提示输入root密码"><a href="#3、根据提示输入root密码" class="headerlink" title="3、根据提示输入root密码"></a>3、根据提示输入root密码</h4><p><img src="/img/fjkmayksqx.png"></p><h4 id="4、卸载文件系统"><a href="#4、卸载文件系统" class="headerlink" title="4、卸载文件系统"></a>4、卸载文件系统</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">umount /dev/vda1<br></code></pre></td></tr></table></figure><h4 id="5、使用fsck命令进行修复"><a href="#5、使用fsck命令进行修复" class="headerlink" title="5、使用fsck命令进行修复"></a>5、使用fsck命令进行修复</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">fsck.ext3  -p /dev/vda1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 这里的ext3要根据自身文件系统类型选择，可通过 df -Th 命令查看。</span></span><br></code></pre></td></tr></table></figure><p>若上面的命令修复无果，可使用下面的命令尝试修复。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fsck.ext3 -y /dev/vda1<br></code></pre></td></tr></table></figure><p><strong>提示完成后，reboot重启服务器即可正常启动。</strong></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何检测处理器是否支持AES-NI指令集？</title>
    <link href="/2022/06/03/63475/"/>
    <url>/2022/06/03/63475/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是AES-NI？"><a href="#什么是AES-NI？" class="headerlink" title="什么是AES-NI？"></a>什么是AES-NI？</h2><p>高级加密标准指令集（或称英特尔高级加密标准新指令，简称AES-NI）是一个x86指令集架构的扩展，用于Intel和AMD微处理器，由Intel在2008年3月提出。该指令集的目的是改进应用程序使用高级加密标准（AES）执行加密和解密的速度。</p><p>详细介绍可参考<a href="https://zh.wikipedia.org/wiki/AES%25E6%258C%2587%25E4%25BB%25A4%25E9%259B%2586">链接</a></p><h2 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h2><p>Windows服务器借助第三方工具，我这里使用的是 CPU-Z，<a href="http://www.cpuid.com/cpuz.php">点击下载</a></p><p>此处下载、安装步骤省略，直接查看结果，如图：</p><p><img src="/img/slwy6m64xw.png"></p><h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><p>使用命令【grep aes &#x2F;proc&#x2F;cpuinfo】即可查看，当此命令能返回内容，说明此服务器的处理器是支持AES-NI的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@VM-80-27-centos ~]# grep aes /proc/cpuinfo<br>flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single fsgsbase bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat avx512_vnni<br>flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single fsgsbase bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat avx512_vnni<br>[root@VM-80-27-centos ~]# <br></code></pre></td></tr></table></figure><h2 id="Mac系统"><a href="#Mac系统" class="headerlink" title="Mac系统"></a>Mac系统</h2><p>使用命令【sysctl -n machdep.cpu | grep -i aes】即可查看，当此命令能返回内容，说明此服务器的处理器是支持AES-NI的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">xxx-MB0:~ x$ sysctl -n machdep.cpu | grep -i aes<br>FPU VME DE PSE TSC MSR PAE MCE CX8 APIC SEP MTRR PGE MCA CMOV PAT PSE36 CLFSH DS ACPI MMX FXSR SSE SSE2 SS HTT TM PBE SSE3 PCLMULQDQ DTES64 MON DSCPL VMX SMX EST TM2 SSSE3 FMA CX16 TPR PDCM SSE4.1 SSE4.2 x2APIC MOVBE POPCNT AES PCID XSAVE OSXSAVE SEGLIM64 TSCTMR AVX1.0 RDRAND F16C<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Mac</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/03/hello-world/"/>
    <url>/2022/06/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>df 和 du 命令显示不一致？</title>
    <link href="/2021/12/11/52536/"/>
    <url>/2021/12/11/52536/</url>
    
    <content type="html"><![CDATA[<h2 id="常见原因"><a href="#常见原因" class="headerlink" title="常见原因"></a>常见原因</h2><h4 id="1、有程序打开了文件，此文件被删除，但是程序没关闭，此文件所占用空间未释放。通过lsof命令可确认此情况"><a href="#1、有程序打开了文件，此文件被删除，但是程序没关闭，此文件所占用空间未释放。通过lsof命令可确认此情况" class="headerlink" title="1、有程序打开了文件，此文件被删除，但是程序没关闭，此文件所占用空间未释放。通过lsof命令可确认此情况"></a>1、有程序打开了文件，此文件被删除，但是程序没关闭，此文件所占用空间未释放。通过lsof命令可确认此情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsof  | grep -i delete<br></code></pre></td></tr></table></figure><h4 id="2、挂载点下有子目录被再次挂在到别处，这种情况下会隐藏原目录内容。"><a href="#2、挂载点下有子目录被再次挂在到别处，这种情况下会隐藏原目录内容。" class="headerlink" title="2、挂载点下有子目录被再次挂在到别处，这种情况下会隐藏原目录内容。"></a>2、挂载点下有子目录被再次挂在到别处，这种情况下会隐藏原目录内容。</h4><ul><li>什么是有嵌套挂载？</li></ul><p>系统盘目录是挂在到根目录&#x2F;的，但是数据盘是挂在到根目录下的&#x2F;data目录，这时就是嵌套挂载。</p><ul><li>举例说明</li></ul><p>例如&#x2F;data目录原来有5G数据，但是此时将 数据盘vdb挂在到&#x2F;data目录，此时du统计不到原&#x2F;data目录的5G数据。</p><p>这时我们想要在不卸载数据盘的情况下确认根目录下的data目录原本是否有数据，则需要bind挂载它的上层目录&#x2F;：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /new; mount -o bind / /new ; du -sh /new ; umount /new<br></code></pre></td></tr></table></figure><h4 id="3、对于共享文件系统，可能会被其他服务器挂载了，请检查另外的服务器是否存在以上1和2-的场景"><a href="#3、对于共享文件系统，可能会被其他服务器挂载了，请检查另外的服务器是否存在以上1和2-的场景" class="headerlink" title="3、对于共享文件系统，可能会被其他服务器挂载了，请检查另外的服务器是否存在以上1和2 的场景"></a>3、对于共享文件系统，可能会被其他服务器挂载了，请检查另外的服务器是否存在以上1和2 的场景</h4><h4 id="4、xfs文件系统异常"><a href="#4、xfs文件系统异常" class="headerlink" title="4、xfs文件系统异常"></a>4、xfs文件系统异常</h4><p>如果是xfs文件系统，已排除上诉3种情况，重启机器后，空间还未释放，可以检测下&#x2F;var&#x2F;log&#x2F;messages日志文件是否有文件系统相关报错，在确保数据已备份的情况下，使用 xfs_repair 命令修复。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>du</tag>
      
      <tag>sh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>磁盘扩容报错</title>
    <link href="/2021/10/06/32451/"/>
    <url>/2021/10/06/32451/</url>
    
    <content type="html"><![CDATA[<h2 id="报错信息："><a href="#报错信息：" class="headerlink" title="报错信息："></a>报错信息：</h2><h2 id="resize2fs-New-size-too-large-to-be-expressed-in-32-bits"><a href="#resize2fs-New-size-too-large-to-be-expressed-in-32-bits" class="headerlink" title="resize2fs: New size too large to be expressed in 32 bits"></a>resize2fs: New size too large to be expressed in 32 bits</h2><h2 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因:"></a>报错原因:</h2><p>普通ext4文件系统，无法处理大于16TB的分区</p><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>下载编译e2fsprogs-1.43以后的版本（通常下载最新稳定版本), 之后用该版本的resize2fs 加上-b选项扩容<br>下载最新版本的稳定tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://git.kernel.org/pub/scm/fs/ext2/e2fsprogs.git/snapshot/e2fsprogs-1.45.6.tar.gz<br>tar xf e2fsprogs-1.45.6.tar.gz <br>cd e2fsprogs-1.45.6/<br>./configure --prefix=/usr/local/e2fsprogs<br>make<br>make install<br>cd /usr/local/e2fsprogs/sbin/<br></code></pre></td></tr></table></figure><h3 id="注意修改参数"><a href="#注意修改参数" class="headerlink" title="注意修改参数"></a>注意修改参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./e2fsck /dev/xxxx<br>./resize2fs -b /dev/xxxx<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用文档</title>
    <link href="/2021/07/06/1/"/>
    <url>/2021/07/06/1/</url>
    
    <content type="html"><![CDATA[<h3 id="添加文章"><a href="#添加文章" class="headerlink" title="添加文章"></a>添加文章</h3><h4 id="1、在本地博客根目录鼠标右击点击【Git-bash-here】"><a href="#1、在本地博客根目录鼠标右击点击【Git-bash-here】" class="headerlink" title="1、在本地博客根目录鼠标右击点击【Git bash here】"></a>1、在本地博客根目录鼠标右击点击【Git bash here】</h4><h4 id="2、新建一篇文档"><a href="#2、新建一篇文档" class="headerlink" title="2、新建一篇文档"></a>2、新建一篇文档</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new 文章名称<br></code></pre></td></tr></table></figure><h4 id="3、编辑文章"><a href="#3、编辑文章" class="headerlink" title="3、编辑文章"></a>3、编辑文章</h4><h4 id="4、发布"><a href="#4、发布" class="headerlink" title="4、发布"></a>4、发布</h4><p>hexo三连</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure><h4 id="5、不出意外一会就可以访问到新文章了"><a href="#5、不出意外一会就可以访问到新文章了" class="headerlink" title="5、不出意外一会就可以访问到新文章了"></a>5、不出意外一会就可以访问到新文章了</h4>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu系统网卡异常</title>
    <link href="/2021/06/03/23455/"/>
    <url>/2021/06/03/23455/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu系统网卡异常"><a href="#Ubuntu系统网卡异常" class="headerlink" title="Ubuntu系统网卡异常"></a>Ubuntu系统网卡异常</h1><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>ifconfig 查看没有获取到IP。</p><p>启动网络服务报错此服务找不到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">abuntu@VM-32-2-ubuntu:sudo service network restart<br>Eailed to restart network.service:Unit network.service not found<br></code></pre></td></tr></table></figure><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><p>1、执行dhclient命令获取到了IP了，网络也通了，以为问题解决了</p><p>但是重启机器后依然是获取不到IP的状态；</p><p>2、网上看了下Ubuntu 20是 <strong>netplan</strong> 工具管理的网络，在机器上面执行了下，发现没有这个命令；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash: netplan:command not found<br></code></pre></td></tr></table></figure><p>3、执行如下命令安装一下这个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install netplan.io<br></code></pre></td></tr></table></figure><p>4、设置 systemd-networkd 服务开机自启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable systemd-networkd.service<br></code></pre></td></tr></table></figure><p>5、重启服务器网络正常启动。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
